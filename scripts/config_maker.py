#!/usr/bin/python3

"""
File: config_maker.py 
Author: Irreq 
Date: 2024-04-05

Description: Script for converting JSON or YAML file to config file in a specific language
"""

import argparse
import datetime

USAGE = (
    "Usage: python3 config_maker.py /path/to/config.json /path/to/output --<language>"
)


def eval_expression(expr: str, table: dict):
    items = expr.split(" ")

    if len(items) == 1:
        first = items[0]

        if first in table:
            new_value = str(table[first])
            item = eval_expression(new_value, table)
        else:
            item = first

        return f"{item} "
    else:
        return (
            f"{eval_expression(items[0], table)} "
            f'{eval_expression(" ".join(items[1:]), table)}'
        )


class ConfigBuilder(object):
    def __init__(self, config, file):
        self.config = config
        self.file = file

    def is_expression(self, value):
        return isinstance(value, str)

    def write(self, data):
        with open(self.file, "w+") as config:
            config.write(self.header())
            for key, value in data.items():
                if isinstance(value, str):
                    if value[0] == "'":
                        output = f'"{value[1:-1]}"'
                        config.write(self.data(key, output))
                        continue
                if self.is_expression(value):
                    try:
                        output = eval(eval_expression(value, data))

                    except Exception:
                        output = f'"{value}"'

                else:
                    output = value

                config.write(self.data(key, self.convert(output)))

            config.write(self.footer())

            config.close()

    def header(self):
        return "#This is default header\n"

    def data(self, key: str, output: object) -> str:
        return f"{key} = {output}\n"

    def footer(self):
        return "#This is default footer\n"

    def convert(self, item):
        return item


class C(ConfigBuilder):
    def __init__(self, config, file):
        super().__init__(config, file)

    def header(self):
        now = datetime.datetime.now()  # .isoformat()
        return f"""// path: {self.file}

#ifndef CONFIG_H
#define CONFIG_H

// NOTICE!

// DO NOT EDIT THIS FILE!
// THIS FILE IS AUTO-GENERATED BY A SCRIPT. IF YOU WANT TO EDIT THE CONFIGURATIONS
// CHANGE THE VALUES IN: "{self.config}".

// GENERATED: {now}

"""

    def data(self, key: str, output: object) -> str:
        if key == "IP_ADDRESSES":
            formatted_ips = ", ".join([f'"{ip}"' for ip in output])
            return f"#define {key} {{{formatted_ips}}}\n"
        elif key == "UDP_PORTS":
            formatted_ports = ", ".join([str(port) for port in output[:data["N_FPGAS"]]])
            return f"#define {key} {{{formatted_ports}}}\n"
        else:
            return f"#define {key} {output}\n"

    def footer(self):
        return "\n#endif\n"

    def convert(self, item):
        if isinstance(item, bool):
            return 1 * item
        else:
            return item


class Python(ConfigBuilder):
    def __init__(self, config, file):
        super().__init__(config, file)

    def header(self):
        now = datetime.datetime.now()  # .isoformat()
        return f"""#!/usr/bin/python3
# path: {self.file}

# NOTICE!

# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTO-GENERATED BY A SCRIPT. IF YOU WANT TO EDIT THE CONFIGURATIONS
# CHANGE THE VALUES IN: "{self.config}".

# GENERATED: {now}

"""

    def data(self, key: str, output: object) -> str:

        return f"{key} = {output}\n"

    def footer(self):
        return ""


class Cython(ConfigBuilder):
    def __init__(self, config, file):
        super().__init__(config, file)

    def header(self):
        now = datetime.datetime.now()  # .isoformat()
        return f"""# cython: language_level=3
# distutils: language=c

# path: {self.file}

# NOTICE!

# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTO-GENERATED BY A SCRIPT. IF YOU WANT TO EDIT THE CONFIGURATIONS
# CHANGE THE VALUES IN: "{self.config}".

# GENERATED: {now}

"""

    def data(self, key: str, output: object) -> str:
        return f"DEF {key} = {output}\n"

    def footer(self):
        return ""


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate configuration files")

    parser.add_argument("in_file", help="target config file")
    parser.add_argument("out", help="output directory")

    parser.add_argument(
        "--python", action="store_true", help="generate python config file"
    )
    parser.add_argument(
        "--cython", action="store_true", help="generate cython config file"
    )
    parser.add_argument("--c", action="store_true", help="generate c config file")

    # Parse the command line arguments
    args = parser.parse_args()

    # print(args.in_file)

    with open(args.in_file, "r") as file:
        if ".json" in args.in_file:
            import json

            data = json.load(file)
        elif ".yaml" in args.in_file:
            import yaml

            data = yaml.safe_load(file)
            n_fpgas = data.get("N_FPGAS", 1)  # Default to 1 if N_FPGAS is not specified
            if n_fpgas > len(data["IP_ADDRESSES"]) or n_fpgas > len(data["UDP_PORTS"]):
                raise ValueError(
                    "N_FPGAS cannot be greater than the number of IP addresses or udp ports"
                )
            data["IP_ADDRESSES"] = data["IP_ADDRESSES"][:n_fpgas]
            data["UDP_PORTS"] = data["UDP_PORTS"][:n_fpgas]
        else:
            raise RuntimeError(USAGE)

    languages = {
        "python": (Python, "/config.py"),
        "cython": (Cython, "/config.pxd"),
        "c": (C, "/config.h"),
    }

    for language, (writer, path) in languages.items():
        if getattr(args, language, False):
            print(f"Generating {language} configuration at: {args.out}{path}")
            writer(args.in_file, args.out + path).write(data)